<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="xs3p.xsl"?>
<!--

SQBL - The Simple ( or Structured ) Questionnaire Building Language 
  www.sqbl.org

The SQBL Schema is free software distributed within the public domain.
You are free to download, remix, change and modify these schemas to your hearts content. 

SQBL and associated Schema are distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.

      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.

-->

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="sqbl:1" xmlns:qwac="qwac:reusable:1" xmlns:sqbl="sqbl:1"
   targetNamespace="sqbl:1" elementFormDefault="qualified" attributeFormDefault="unqualified">
   <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="./xml.xsd" />
   <xs:annotation>
      <xs:documentation> The Simple ( or Structured ) Questionnaire Building Language or SQBL is a formalised
         serialisation of the "Structured Questionnaire Theroum". The purpose of this format is to enable survey
         designers and researchers to produce questionnaires that are able to effectively target respondents, quicker
         and easier than has previously been able, while focusing on maximum machine support for processing at all
         stages of data collection. This is achieved, by encouraging the creation of structured and hierarchical
         questionnaire specifications. This documentation includes tips for content creators, systems designers and user
         interface designers for both applications creating SQBL documents (for example systems like the Canard Question
         Module Editor) and creators of systems that convert SQBL into Questionnaires/Form/Web Surveys/etc (eg. the Roxy
         SQBL-Xforms transformation tools). This schema should be accompanied with a conformant dogDemographics.sqbl
         SQBL document. When there is a need for examples, they are drawn from this document. When designing systems,
         the dogDemographics.sqbl should be considered the definative test case, and any systems that work with this
         document MUST meet the requirements of this document, and MAY meet the optional requirements.
      </xs:documentation>
   </xs:annotation>
   <!-- 
      Need to determine if a questionnaire is just a Question Module that has been "blessed" for a specific usage.
      May be able to store instrument details in DDI, and then just reference from an Instrument to a SQBL document.
      
      xs:element name="QuestionnaireSpecification">
      <xs:annotation>
         <xs:documentation>A questionnaire specification in the SQBL format document describing the abstract notion of a
            questionnaire or survey instrument (this document uses the term questionnaire). The content that is captured
            within a specification is transformed into a questionnaire instrument and allows for reproducible processes
            for generating questionnaires. A questionnaire, in the SQBL format, is quite a simple object where it
            contains a multilingual text component and an ordered list of references to reusable "Question Modules"
            
            Questionnaire Specification are still under active development.
         </xs:documentation>
      </xs:annotation>
      <xs:complexType>
         <xs:complexContent>
            <xs:extension base="Versionable">
               <xs:sequence>
                  <xs:element name="LongName" minOccurs="0" maxOccurs="unbounded" type="xs:string">
                     <xs:annotation>
                        <xs:documentation>The display name for an instrument</xs:documentation>
                     </xs:annotation>
                  </xs:element>
                  <xs:element name="QuestionModules">
                     <xs:annotation>
                        <xs:documentation>
                           Contains an ordered list of question modules that comprise of the total logic necessary for a Questionnaire.
                           The list of Modules in this element MUST retain document order throughout automated transformations
                           and must be presented to users in the order given.
                        </xs:documentation>
                     </xs:annotation>
                     <xs:complexType>
                        <xs:sequence>
                            <xs:element name="QuestionModuleReference" type="ReferenceType" minOccurs="0" maxOccurs="unbounded">
                               <xs:annotation>
                                  <xs:documentation>A reference to a question module that comprises a part of the final
                                     questionnaire. This is a URI off to an XML Document that describes a SQBL QuestionModule. The
                                     URI can either be a standard URL to a static document, or a URI to a server that serves up a
                                     document via CGI parameters. </xs:documentation>
                               </xs:annotation>
                            </xs:element>
                        </xs:sequence>
                     </xs:complexType>
                  </xs:element>
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>
   </xs:element -->
   <xs:element name="QuestionModule">
      <xs:annotation>
         <xs:documentation>
            <![CDATA[
            QuestionModule are the simple, yet powerful, core construct within the SQBL data model. A
            Question modules is made up of 5 objects, which when compined provide a robust description of the activities
            necessary to produce a wide variety of static or dynamic questionnaires. These are:
            
              * TextComponent - A set of multilingual content necessary for understanding the semantics of this module.
              * IncomingPopulation - A Reference to a Population ADministration Language (PAdL) population that determines who answers this module.
              * ModuleLogic - A hierachical structure containing the questions and sequencing rules between those questions.
              * DerivedDataIitems - A collection of data items that aggregate multiple responses from within this module specific data elements.
              * Submodules - A list of references to SubModules that are a part of this module and need to be asked as one coherent block. 
              ]]>
         </xs:documentation>
      </xs:annotation>
      <xs:complexType>
         <xs:complexContent>
            <xs:extension base="Versionable">
               <xs:sequence>
                  <xs:element name="TextComponent" minOccurs="0" maxOccurs="unbounded">
                     <xs:complexType>
                        <xs:all>
                           <xs:element name="LongName" minOccurs="0" maxOccurs="1" type="xs:string">
                              <xs:annotation>
                                 <xs:documentation>The human readable name of this module, used in searching. When
                                    comparing the Long Name and Title of a module, the Long Name should be considered
                                    the "internal or private" name and as a stand alone title, whereas the title would
                                    be "external or public" title presented to a user, within the context of the greater
                                    questionnaire. For example, two modules may share the Title "Pet Ownership" as
                                    presented to a user, while one has the more descriptive Long Name "Pet Ownership,
                                    2013 Long Form edition", the other "Pet Ownership, Short (4 Question) edition"
                                 </xs:documentation>
                              </xs:annotation>
                           </xs:element>
                           <xs:element name="Title" minOccurs="0" maxOccurs="1" type="xs:string">
                              <xs:annotation>
                                 <xs:documentation>The name of this module as presented to a respondent of a survey.
                                 </xs:documentation>
                              </xs:annotation>
                           </xs:element>
                           <xs:element name="Purpose" minOccurs="0" maxOccurs="1" type="xs:string">
                              <xs:annotation>
                                 <xs:documentation>Why this specific set of questions is being asked of the chosen
                                    respondents in this collection?</xs:documentation>
                              </xs:annotation>
                           </xs:element>
                           <xs:element name="TargetRespondent" minOccurs="0" maxOccurs="1" type="xs:string">
                              <xs:annotation>
                                 <xs:documentation>Who this module is attempting gather data from in a short and general sense.</xs:documentation>
                              </xs:annotation>
                           </xs:element>
                        </xs:all>
                        <xs:attribute ref="xml:lang">
                           <xs:annotation>
                              <xs:documentation>The ISO language code for this TextComponent. This must be unique and is
                                 enfored in schema.</xs:documentation>
                           </xs:annotation>
                        </xs:attribute>
                     </xs:complexType>
                  </xs:element>
                  <xs:element name="IncomingPopulation" minOccurs="0" maxOccurs="unbounded" type="ReferenceType">
                     <xs:annotation>
                        <xs:documentation>Who can perform this question module? A URI Reference to a Population
                           ADministration Language (PAdL) population. When a questionnaire is created from a SQBL
                           Questionnaire Specification, a respondent MUST only perform a given QuestionModule if and
                           only if they are are determined to be in this population. If no incoming population exists,
                           it MUST be interpretted that this module is to be answered by all respondents.
                        </xs:documentation>
                     </xs:annotation>
                  </xs:element>
                  <xs:element name="WordSubstitutions" minOccurs="0" maxOccurs="unbounded">
                     <xs:annotation>
                        <xs:documentation>
                           Contains a list of locally defines variables for producing dynamic text in questions based on responses to other questions.
                        </xs:documentation>
                     </xs:annotation>
                     <xs:complexType>
                        <xs:sequence>
                           <xs:element name="WordSub" type="WordSubType" />
                        </xs:sequence>
                     </xs:complexType>
                  </xs:element>
                  <xs:element name="ModuleLogic" minOccurs="1" maxOccurs="1" type="LogicHead">
                     <xs:annotation>
                        <xs:documentation>What questions are asked, and how are respondents routed between them? The
                           concept of questionnaire logic in SQBL documents runs counter to most traditional and
                           unstructured ways of describing routing within questionnaires. Here questionnaire modules
                           follow the "Structured Questionnaire Theorum", that describes the routing of questionnaires
                           using a hierarchical approach similar to structured programming. Within the logical component
                           of a question module we describe a tree that can then be interpretted by computers and
                           expressed as a web form, electronic interview instrument or a paper survey froma single
                           specification. Whether this it is appropriate within a given agency to express a
                           specification in a multi-mode way is considered outside of scope for SQBL, and is an agency
                           information governance issue.</xs:documentation>
                     </xs:annotation>
                  </xs:element>
                  <xs:element name="DerivedDataItems" minOccurs="0" maxOccurs="1">
                     <xs:annotation>
                        <xs:documentation>A collection of data items that aggregate multiple responses from within this
                           module specific data elements. This section is still under active development, and the role
                           and interactivity across modules of Data Elements is yet to be full researched. In time, the
                           derivation of data items will provide for the ability to have cross-module branching and
                           logic. </xs:documentation>
                     </xs:annotation>
                     <xs:complexType>
                        <xs:sequence>
                           <xs:element name="DerivedDataItem" type="DerivedDataItemType" minOccurs="0"
                              maxOccurs="unbounded" />
                        </xs:sequence>
                     </xs:complexType>
                  </xs:element>
                  <xs:element name="Submodules" minOccurs="0" maxOccurs="1">
                     <xs:complexType>
                        <xs:sequence minOccurs="0" maxOccurs="unbounded">
                           <xs:element name="SubModuleReference" minOccurs="0" maxOccurs="unbounded"
                              type="ReferenceType">
                              <xs:annotation>
                                 <xs:documentation>A URI reference to the submodules that a respondent must be presented
                                    with, if they have been presented with the current module. If a user is given an
                                    early exit from the module logic using a ModuleExitPoint they must immediately
                                    continue to any submodules within the module. </xs:documentation>
                              </xs:annotation>
                           </xs:element>
                        </xs:sequence>
                     </xs:complexType>
                  </xs:element>
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>
      <xs:unique name="QuestionModuleTextLanguageMustBeUnique">
         <xs:selector xpath="sqbl:TextComponent" />
         <xs:field xpath="@xml:lang" />
      </xs:unique>
   </xs:element>
   <xs:complexType name="DerivedDataItemType">
      <xs:annotation>
         <xs:documentation> Still under development. Will contain a reference to a Data Element and a decision table that
            links to questions IN THIS MODULE and specifies how the responses to those decitate how a complete data element
            is populated with data.</xs:documentation>
      </xs:annotation>
   </xs:complexType>

   <xs:complexType name="RichTextContent" mixed="true">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:group ref="RichTextContent.group" />
      </xs:choice>
   </xs:complexType>

   <xs:group name="RichTextContent.group">
      <xs:choice>
         <xs:annotation>
            <xs:documentation>Here we do a hackjob reimplementation of a subset of HTML elements to support a very restricted set of rich-text elements.</xs:documentation>
         </xs:annotation>
         <xs:element name="strong" type="RichTextContent" />
         <xs:element name="em" type="RichTextContent" />
         <xs:element name="p" type="RichTextContent" />
         <xs:element name="sub" type="WordSubRef">
            <xs:annotation>
               <xs:documentation>
                  This is a reference to the word substitution that this dynamic text references.
                  There are ONLY 3 possible types of element this can reference, enumerated below
                  with the REQUIRED behaviour: 
                     1. A Question  - The respondent value of the refered question is inserted OR
                                       if the question is unanswered, text that specifies the question
                                       MAY be inserted
                     2. A WordSub   - The computed value of the refered wordsub is inserted as per the
                                       rules of the decision table it contains.
                     3. A Loop      - Depending on the type of Loop, either the loop counter or if the
                                       loop is based on responses to a Multi-choice question then the value
                                       of the text of the current iteration. 
                  Software that creates SQBL documents MUST ensure that this IDREF matches to the ID of an
                  element of one of the the above types ONLY.
               </xs:documentation>
            </xs:annotation>
         </xs:element>
      </xs:choice>
   </xs:group>

   <xs:complexType name="WordSubRef">
      <xs:attribute name="ref" type="xs:IDREF" />
   </xs:complexType>
   <xs:complexType name="DynamicTextType" mixed="true">
      <xs:annotation>
         <xs:documentation>Structures the behavior of dynamic or static text within the instrument.</xs:documentation>
      </xs:annotation>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:group ref="RichTextContent.group" />
      </xs:choice>
   </xs:complexType>

   <xs:complexType name="WordSubType">
      <xs:annotation>
         <xs:documentation>Text which has a dynamic value based on prior questions. This section will probably undergo a lot of change. Word
            substitutions seem like they may need a lot of work, and may be one of the things that needs to be
            reusable within a module.</xs:documentation>
      </xs:annotation>
      <xs:sequence>
         <xs:element name="Condition" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation>
               <xs:documentation>The order of Condition elements in a sequence guide is important and MUST NOT be
                  changed without a survey editors understanding. Since it is the first condition that is true that is
                  evaluated, changing the order of conditionals my change the order of a survey.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:sequence>
                  <xs:element name="ResultString" type="MultilingualPlainTextType" />
                  <xs:element name="ValueOf" minOccurs="1" maxOccurs="unbounded" type="ValueOfType">
                     <xs:annotation>
                        <xs:documentation>The order of the ValueOf elements does not matter, as they are all boolean
                           'and'ed together to for the final condition</xs:documentation>
                     </xs:annotation>
                  </xs:element>
               </xs:sequence>
            </xs:complexType>
         </xs:element>
      </xs:sequence>
      <xs:attribute name="static" type="xs:string" use="optional">
         <xs:annotation>
            <xs:documentation>The value of the field if Dynamicness can't be performs, eg. Javascript disabled
               web-forms or paper-based forms.</xs:documentation>
         </xs:annotation>
      </xs:attribute>
      <xs:attribute name="default" type="xs:string" use="optional">
         <xs:annotation>
            <xs:documentation>The initial value of the text field.</xs:documentation>
         </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:ID" />
   </xs:complexType>

   <xs:complexType name="BaseQuestionType">
   <xs:annotation>
      <xs:documentation>The BaseQuestionType serves as the abstraction of Questions and QuestionGroups and future objects
         that can act as questions within question flow.</xs:documentation>
   </xs:annotation>
   <xs:complexContent>
      <xs:extension base="BaseNamedType">
         <xs:sequence>
            <xs:element name="TextComponent" minOccurs="0" maxOccurs="unbounded">
               <xs:annotation>
                  <xs:documentation> The Text component of a question is all of the human readable parts that help
                     describe a question. These are grouped like this to make parsing easy from a systems point of
                     view, as it make the repetition of repeatable language parts easier to manage. The xml:lang
                     attribute for the TextComponent question MUST be unique for a given question, and is enforced in
                     schema. </xs:documentation>
               </xs:annotation>
               <xs:complexType>
                  <xs:all>
                     <xs:element name="QuestionText" type="DynamicTextType" minOccurs="1" maxOccurs="1">
                        <xs:annotation>
                           <xs:documentation>The text of the question presented in the instrument that is presented
                              to a respondent.</xs:documentation>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="Instruction" type="DynamicTextType" minOccurs="0" maxOccurs="1">
                        <xs:annotation>
                           <xs:documentation>This provides the textual content of the instruction. This is considered
                              additional content that may be useful in aiding the respondent in answering this
                              question. Content may be includes and excludes fora response or notes that guide
                              response. </xs:documentation>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="QuestionIntent" type="xs:string" minOccurs="0" maxOccurs="1">
                        <xs:annotation>
                           <xs:documentation>Why this question is included in this module, and why it is being asked
                              in this way. This is content that is not presented to a respondent.</xs:documentation>
                        </xs:annotation>
                     </xs:element>
                  </xs:all>
                  <xs:attribute ref="xml:lang" use="required" />
               </xs:complexType>
            </xs:element>
         </xs:sequence>
      </xs:extension>
   </xs:complexContent>
   </xs:complexType>
   
   <xs:complexType name="QuestionType">
      <xs:annotation>
         <xs:documentation>The QuestionType serves as the base for "question-like objects" that serves to collection
            data from a respondant. Questions that extend this MUST NOT include any internal logic asides from
            randomisation of order.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="BaseQuestionType">
            <xs:sequence>
               <xs:element name="ResponseType">
                  <xs:annotation>
                     <xs:documentation> This is a list of currently defined Response Types for a given question. These
                        are meant to give a questionnaire designer the ability to describe what the values of a question
                        should be, and to some extend how they are to be presented. For example, a question of Age,
                        might have a 'Number' response type, with a minimum of 0, a maxmimum of 100, and a step value of
                        1. This is a definition of what the data should be. At yet, the schema does not define if or how
                        these restrictions are presented to a respondent, and are yet to be determined to be "in scope
                        of SQBL". So while a designer can dictate the words that are presented if an age is given below
                        0, there is still no content that describes if or how this is enforced when a respondent given
                        'invalid' data. </xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                     <xs:choice minOccurs="1" maxOccurs="unbounded">
                        <xs:element name="Text">
                           <xs:complexType>
                              <xs:all>
                                 <xs:element name="Hint" type="MultilingualPlainTextType" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation> The text fields under here will be displayed if the string the
                                          user requires information on what can be entered under for this value.
                                       </xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                                 <xs:element name="MaximumLength" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation>The "value" attribute defines the maximum allowed length for
                                          this response. The text fields under here will be displayed if the string the
                                          user enters is too long. </xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                       <xs:complexContent>
                                          <xs:extension base="MultilingualPlainTextType">
                                             <xs:attribute name="value" use="required" type="xs:nonNegativeInteger" />
                                          </xs:extension>
                                       </xs:complexContent>
                                    </xs:complexType>
                                 </xs:element>
                                 <xs:element name="MinimumLength" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation>The "value" attribute defines the minimum allowed length for
                                          this response. The text fields under here will be displayed if the string the
                                          user enters is too short. </xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                       <xs:complexContent>
                                          <xs:extension base="MultilingualPlainTextType">
                                             <xs:attribute name="value" use="required" type="xs:nonNegativeInteger" />
                                          </xs:extension>
                                       </xs:complexContent>
                                    </xs:complexType>
                                 </xs:element>
                              </xs:all>
                              <xs:attribute name="displayType">
                                 <xs:annotation>
                                    <xs:documentation>This indicates how the field should be display, either long or
                                       short. The final fixed list for this is still under design. How short, medium and
                                       long are interpreted is left to the creator of any given presentation and
                                       expression transformation tool - however, a short field MUST be identifiable as
                                       smaller than a medium field, which MUST be identifiable as shorter than a long
                                       field. Eg. short would be visually smaller than a medium on a visual medium.
                                    </xs:documentation>
                                 </xs:annotation>
                                 <xs:simpleType>
                                    <xs:restriction base="xs:string">
                                       <xs:enumeration value="short" />
                                       <xs:enumeration value="medium" />
                                       <xs:enumeration value="long" />
                                    </xs:restriction>
                                 </xs:simpleType>
                              </xs:attribute>
                           </xs:complexType>
                        </xs:element>
                        <xs:element name="Number">
                           <xs:complexType>
                              <xs:all>
                                 <xs:element name="Hint" type="MultilingualPlainTextType" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation> The text fields under here will be displayed if the string the
                                          user requires information on what can be entered under for this value.
                                       </xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                                 <xs:element name="Maximum" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation>The "value" attribute defines the maximum allowed value for
                                          this response. The text fields under here will be displayed if the number the
                                          user enters is too large. </xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                       <xs:complexContent>
                                          <xs:extension base="MultilingualPlainTextType">
                                             <xs:attribute name="value" use="required" type="xs:decimal" />
                                          </xs:extension>
                                       </xs:complexContent>
                                    </xs:complexType>
                                 </xs:element>
                                 <xs:element name="Minimum" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation>The "value" attribute defines the minimum allowed value for
                                          this response. The text fields under here will be displayed if the string the
                                          user enters is too small. </xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                       <xs:complexContent>
                                          <xs:extension base="MultilingualPlainTextType">
                                             <xs:attribute name="value" use="required" type="xs:decimal" />
                                          </xs:extension>
                                       </xs:complexContent>
                                    </xs:complexType>
                                 </xs:element>
                                 <xs:element name="Step" minOccurs="0">
                                    <xs:annotation>
                                       <xs:documentation>The "value" attribute defines the multiple that a value must be
                                          of to be considered valid. As SQBL does not differentiate between integers and
                                          floats, the way to determine this is to have a step value of 1. If the Step
                                          element does not exist for a response, it MUST be interpreted as 1. The text
                                          fields under here will be displayed if the string the user enters is not a
                                          multiple of the step. </xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                       <xs:complexContent>
                                          <xs:extension base="MultilingualPlainTextType">
                                             <xs:attribute name="value" use="required" type="xs:decimal" />
                                          </xs:extension>
                                       </xs:complexContent>
                                    </xs:complexType>
                                 </xs:element>
                                 <xs:element name="Prefix" minOccurs="0" type="MultilingualPlainTextType">
                                    <xs:annotation>
                                       <xs:documentation> The text presented before a given number field on an
                                          instrument. For example, "$" or "USD" </xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                                 <xs:element name="Suffix" minOccurs="0" type="MultilingualPlainTextType">
                                    <xs:annotation>
                                       <xs:documentation> The text presented after a given number field on an
                                          instrument. For example, "kilograms", "kgs", "per hour" </xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                              </xs:all>
                           </xs:complexType>
                        </xs:element>
                        <xs:element name="CodeList" type="CodeListType" />
                        <!-- xs:element name="ValueDomainReference">
                           <xs:annotation>
                              <xs:documentation>A reference to a defined 111-79 Value domain for the question. When
                                 attempting to perform cross module routing, such as in population routing or branching,
                                 rather than reference the value of a question, "Data Elements" as identified by their
                                 DataElementConceptReference (aka. the ObjectClass and Property) joined with their value
                                 domain. As such, if you wish to have the value of a response for a question used to
                                 apply routing across other surveys, linking to an existing value domain is required.
                                 
                                 A question MUST ONLY have a Value Domain Reference if it includes a valid "DataElementConceptReference". 
                              </xs:documentation>
                           </xs:annotation>
                        </xs:element -->
                     </xs:choice>
                     <xs:attribute name="canRefuse" default="false" type="xs:boolean">
                        <xs:annotation>
                           <xs:documentation> Indicates that a respondent can EXPLICITLY refuse to answer a question.
                              This may be useful for questions where respondents have legitimate issues answering a
                              question of a sensitive or personal nature. What happens if a user refuses to answer a
                              question where the "canRefuse" attribute is set to false is an agency issue of policy and
                              proceedure and is considered strictly out-of-scope of SQBL. </xs:documentation>
                        </xs:annotation>
                     </xs:attribute>
                     <xs:attribute name="canNotKnow" default="false" type="xs:boolean">
                        <xs:annotation>
                           <xs:documentation> Indicates that a respondent can EXPLICITLY indicate that they do not know
                              the answer to answer a question. What happens if a user is unable to answer because they
                              do not know how to answer a question where the "canNotKnow" attribute is set tofalse is an
                              agency issue of policy and proceedure and is considered strictly out-of-scope of SQBL.
                           </xs:documentation>
                        </xs:annotation>
                     </xs:attribute>
                  </xs:complexType>
               </xs:element>
               <xs:element name="SubQuestions" minOccurs="0">
                  <xs:complexType>
                     <xs:sequence>
                        <xs:element name="SubQuestion" minOccurs="1" maxOccurs="unbounded"
                           type="MultilingualPlainTextType" />
                     </xs:sequence>
                  </xs:complexType>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="dataElementReference" type="xs:anyURI" use="optional">
               <xs:annotation>
                  <xs:documentation>
                     A URI reference to a 11179 Data Element that this question is attempting to collect information
                     about. While optional, it is recommended that where possible questionnaire designers include
                     links to 11179 Data Elements as a matter of good practise for metadata description.
                     
                     Areference to a 11179 Data Element may be a link to a webpage that describes the Data Element, 
                     for example [http://meteor.aihw.gov.au/content/index.phtml/itemId/287316] or a URN to a Data
                     Element described in another standard, such as DDI.                     
                     
                     In future versions of SQBL cross-module will be incorporated using 11179 references.
                  </xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="CodeListType">
      <xs:annotation>
         <xs:documentation>A simple, ordered list of code and text pairs presented to a respondent. Due to the very limited
            scope of SQBL, these are not meant to act as classifications, and only have context within their associated
            question. The text for a given code can be multilingual. While this is unenforcable in XML Schema 1.0, when
            creating a Codelist, systems SHOULD include the same set of languages for every CodePair, and UI designers
            SHOULD include prompts that indicate to users if they have not filled in all of the languages for every
            pair.
            
            All CodePairs have a code value that is used in decision tables and in systems, this is not language
            specific. E.g. a code may be "Y" with English text "Yes" and German text "Ja", despite the letter Y having
            no context for this in German. If this is a problem, number can be used instead. At this point codes have no
            maximum length, but future version may shorten this as needed for systems use, as such content creators are
            encouraged to make codes as short as practical.
            
            A CodeList also includes the option for a CodePair to have an associated text field, for example "Other, please specify".
            These fields have no text, and their instruction text MUST be on the question or on the code itself.
              E.g The text for a CodePair should be "Other, please specify" not just "Other").
            The value of the code for this kind of option MUST be the considered value when used in forms logic.
              E.g if a respondant ticks Other (with a code 9) and writes the additional text "I think dogs are smelly" the
              value for this question in logic MUST be "9", NOT "I think dogs are smelly".
              
            A CodeList has a minimum and maximum selection range for capturing how many options a respondant is allowed to
            select. If neither the minimum or maximum are set, they are both equal to '1' so a selection MUST be required.
            For application developers, the minimum and maximum MUST be stored and displayed correctly, so if a minimum is
            larger than the maximim, this MUST be corrected however, how this is managed is managed at an application
            level; eg. software can switch the values behind the scenes or may prompt the user for a correction.
            
            Systems that consume SQBL documents for creating forms SHOULD be permissive and considerate to the intent of
            the document. If the maximum is smaller than the minimum and vice-versa, then the application MAY choose to
            switch these values to interpret them correctly - however this is not a requirement, as such if a SQBL
            document is recieved and has switched min-max values a systems developer may consider this an edge case with
            indetermine side-effects. The presentation of a codelist is left to the Forms UI designer, however it is
            RECOMMENDED that when the maximum is set to one, the codelist be rendered as a set of radio options, and
            rendered as a set of checkboxes otherwise. </xs:documentation>
      </xs:annotation>
      <xs:all>
         <xs:element name="Codes">
            <xs:complexType>
               <xs:sequence>
                  <xs:element name="CodePair" minOccurs="1" maxOccurs="unbounded">
                     <xs:complexType>
                        <xs:complexContent>
                           <xs:extension base="MultilingualPlainTextType">
                              <xs:attribute name="code" use="required" type="xs:token">
                                 <xs:annotation>
                                    <xs:documentation>A short computer readable value to destiguish between response
                                       options that is used in computing decision tables.</xs:documentation>
                                 </xs:annotation>
                              </xs:attribute>
                              <xs:attribute name="freeText" use="optional" type="xs:boolean" default="false">
                                 <xs:annotation>
                                    <xs:documentation> If True, this adds a free text field along with this option for
                                       gathering additional information. A common use case is for allowing a respondent
                                       to select an "Other, please specify option" for a value. Where an how this
                                       additional text box is displayed is up to the form interface designer, however
                                       this field MUST be untyped data - i.e. plain text. </xs:documentation>
                                 </xs:annotation>
                              </xs:attribute>
                           </xs:extension>
                        </xs:complexContent>
                     </xs:complexType>
                  </xs:element>
               </xs:sequence>
            </xs:complexType>
         </xs:element>
         <xs:element name="MinimumSelections" minOccurs="0">
            <xs:annotation>
               <xs:documentation>The text fields under here will be displayed if the string the user selects too few
                  options from this codelist.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="MultilingualPlainTextType">
                     <xs:attribute name="value" use="required" type="xs:positiveInteger" />
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
         </xs:element>
         <xs:element name="MaximumSelections" minOccurs="0">
            <xs:annotation>
               <xs:documentation>The text fields under here will be displayed if the string the user selects too many
                  options from this codelist.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="MultilingualPlainTextType">
                     <xs:attribute name="value" use="required" type="xs:positiveInteger" />
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
         </xs:element>
      </xs:all>

   </xs:complexType>

   <xs:complexType name="MultilingualPlainTextType">
      <xs:annotation>
         <xs:documentation> A multilingual pair is an abstract type that provides a quick way to indicate that a given
            element has a repeated multilingual string component. The Text element As this can be used in a variety of
            place, not every instance of this will have an XS:Unique field indicating that these Text nodes must have
            unique Xml:lang attributes - This is a BUG and an issue that cannot be resolved in simple XML:Schema without
            a lot of duplication. When extending this the schema SHOULD include a uniqueness definition for the Text
            element, however even if this does not occur a tool that uses and writes content of a
            MultilingualPlainTextType MUST ensure programmatically the uniqueness of the xml:lang attribute.
         </xs:documentation>
      </xs:annotation>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:element name="TextComponent">
            <xs:complexType>
               <xs:simpleContent>
                  <xs:extension base="xs:normalizedString">
                     <xs:attribute ref="xml:lang" use="required" />
                  </xs:extension>
               </xs:simpleContent>
            </xs:complexType>
         </xs:element>
      </xs:sequence>
   </xs:complexType>

   <xs:complexType name="LogicNode">
      <xs:annotation>
         <xs:documentation>Provides the basic, extensible structure for control elements used in describing flow logic
            within the instrument. Because of the lack of multiple inheritance in XML Schema, LogicNodes are objects
            which provide the broad description of logical elements, such as Branches or Loops, and MAY contain
            an object inside that extends from LogicHeadType, which allows for the hierachical inclusion of further
            elements defining logic. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="BaseNamedType">
            <xs:sequence>
               <xs:element name="TextComponent" minOccurs="0" maxOccurs="unbounded">
                  <xs:complexType>
                     <xs:all>
                        <xs:element name="Instruction" minOccurs="0" maxOccurs="1">
                           <xs:annotation>
                              <xs:documentation> This provides the textual content of the instruction. This is
                                 considered optional and additional content that may be useful in helping a respondent
                                 navigate through the logic. </xs:documentation>
                           </xs:annotation>
                        </xs:element>
                        <xs:element name="Purpose" minOccurs="0" maxOccurs="1" type="xs:string">
                           <xs:annotation>
                              <xs:documentation> This is designer-facing information on why is this action being taken.
                                 For example, why is the respondent looping a specific number of times, or why are
                                 respondents being branched in a specific way. </xs:documentation>
                           </xs:annotation>
                        </xs:element>
                        <xs:element name="TargetRespondent" minOccurs="0" maxOccurs="1" type="xs:string">
                           <xs:annotation>
                              <xs:documentation>Who this branch is targeting in a short and
                                 general sense. Different to the ObjectClass.</xs:documentation>
                           </xs:annotation>
                        </xs:element>
                     </xs:all>
                     <xs:attribute ref="xml:lang" use="required" />
                  </xs:complexType>
               </xs:element>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="LogicHead">
      <xs:annotation>
         <xs:documentation>A shortcut way of saying an object can include other LogicNodes or
            Questions.</xs:documentation>
      </xs:annotation>
      <xs:choice minOccurs="0" maxOccurs="unbounded">

         <xs:element name="ConditionalTree">
            <xs:annotation>
               <xs:documentation>Provides an if-then-else construct, so that if the stated condition is met, the Then
                  clause is triggered, and otherwise the Else clause is triggered.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="BaseNamedType">
                     <xs:sequence>
                        <xs:element name="TextComponent" minOccurs="0" maxOccurs="unbounded">
                           <xs:complexType>
                              <xs:all>
                                 <xs:element name="Instruction" minOccurs="0" maxOccurs="1" />
                                 <xs:element name="Purpose" minOccurs="0" maxOccurs="1" type="xs:string">
                                    <xs:annotation>
                                       <xs:documentation>Why is this action being
                                          taken?</xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                              </xs:all>
                              <xs:attribute ref="xml:lang" use="required" />
                           </xs:complexType>
                        </xs:element>
                        <xs:element name="SequenceGuide" type="DecisionTable">
                           <xs:annotation>
                              <xs:documentation>The condition which must be met to trigger the Then clause, expressed as
                                 a Coding. The condition is an expression in the programming language used in the
                                 instrument. </xs:documentation>
                           </xs:annotation>
                        </xs:element>
                        <xs:element name="Branch" minOccurs="1" maxOccurs="unbounded">
                           <xs:annotation>
                              <xs:documentation>The BlanchLogic Reference to the control construct which should be
                                 triggered if the associated condition is met. May have an optional ObjectClassReference
                                 that defines the default Object Class for all subsequent child question under this
                                 branch. </xs:documentation>
                           </xs:annotation>
                           <xs:complexType>
                              <xs:complexContent>
                                 <xs:extension base="LogicNode">
                                    <xs:sequence>
                                       <xs:element name="BranchLogic" type="LogicHead" />
                                    </xs:sequence>
                                    <!-- xs:attribute name="ObjectClassReference" type="ReferenceType" use="optional">
                                       <xs:annotation>
                                          <xs:documentation> The Default ObjectClass for all questions within this
                                             module. </xs:documentation>
                                       </xs:annotation>
                                    </xs:attribute -->
                                 </xs:extension>
                              </xs:complexContent>
                           </xs:complexType>
                        </xs:element>
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
            <xs:unique name="ConditionalTreeTextLanguageMustBeUnique">
               <xs:selector xpath="sqbl:TextComponent" />
               <xs:field xpath="@xml:lang" />
            </xs:unique>
         </xs:element>
         <xs:element name="ForLoop">
            <xs:annotation>
               <xs:documentation>ForLoops loop across a given list of responses or a set number of times, similar to a
                  For Loop in programming. This is still under construction, and at least one other form of Loop - the
                  "while" loop is under consideration for inclusion along side For Loops.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="LogicNode">
                     <xs:sequence>
                        <xs:element name="LoopedLogic" type="LogicHead" />
                     </xs:sequence>
                     <xs:attribute name="question" use="required" type="xs:IDREF">
                        <xs:annotation>
                           <xs:documentation>
                              A reference to the question that will be looped over.
                              This MUST be a reference to a quesiton with a single reponse value of either an integer number
                              or a multiple-selection codelist.
                              References to other types of responses may cause side-effects.
                           </xs:documentation>
                        </xs:annotation>
                     </xs:attribute>
                     <!-- xs:attribute name="InitialValue" type="xs:decimal" use="optional" default="0">
                        <xs:annotation>
                           <xs:documentation>The initial value to which the LoopVariable is set. If absent, defaults to
                              0.</xs:documentation>
                        </xs:annotation>
                     </xs:attribute>
                     <xs:attribute name="FinalValue" type="xs:decimal">
                        <xs:annotation>
                           <xs:documentation>The condition which must be met for the Loop's functioning to cease; when
                              this condition is met, control is handed back to the containing control
                              construct.</xs:documentation>
                        </xs:annotation>
                     </xs:attribute>
                     <xs:attribute name="StepValue" type="xs:decimal" use="optional" default="1">
                        <xs:annotation>
                           <xs:documentation>A Coding which is used to manipulate the LoopVariable after each iteration
                              of the Loop's associated ControlConstruct element. If absent, defaults to
                              1.</xs:documentation>
                        </xs:annotation>
                     </xs:attribute -->
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
            <xs:unique name="ForLoopTextLanguageMustBeUnique">
               <xs:selector xpath="sqbl:TextComponent" />
               <xs:field xpath="@xml:lang" />
            </xs:unique>
         </xs:element>
         <!-- Unconvinced sequences are necessary :/ 
            xs:element name="Sequence">
            <xs:complexType>
               <xs:annotation>
                  <xs:documentation>A sequence of stuff.</xs:documentation>
               </xs:annotation>
               <xs:complexContent>
                  <xs:extension base="LogicNode">
                     <xs:sequence>
                        <xs:element name="SequenceElements" type="LogicHead" />
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
         </xs:element>
         <xs:element name="WhileLoop">
            <xs:annotation>
               <xs:documentation>Structures a control construct which repeats while a specified condition is met. Before each
                  iteration the condition is tested. When the condition is not met, control passes back to the containing
                  control construct.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="LogicNode">
                     <xs:sequence>
                        <xs:element name="WhileCondition" type="DecisionTable">
                           <xs:annotation>
                              <xs:documentation>The condition which must be met to trigger the operation of the associated
                                 Coding.</xs:documentation>
                           </xs:annotation>
                        </xs:element>
                        <xs:element name="LoopedElements" type="LogicHead" />
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
         </xs:element -->
         <xs:element name="QuestionGroup">
            <xs:complexType>
               <xs:annotation>
                  <xs:documentation>A semantic grouping of questions used to combine multiple questions into a coherent block.
                     When presented on a form or survey, a QuestionGroup should be presented and numbered like a normal question.
                     Additionally, generated skip patterns may target QuestionGroups like normal questions.
                  
                     Questions contained within a QuestionGroup MUST be considered subordinate questions to the main group and
                     presented visually similar to SubQuestions within a normal question.
                     SubQuestions of Questions within a QuestionGroup SHOULD be made distinct again, an example css override would
                     be: .QuestionGroup .Question .SubQuestion { /* Some rules here */ }.
                     
                     A QuestionGroup can be considered distinct to other sequence types in that it brings together questions that have
                     a strong semantic relationship, with different data type. Eg;
                       2. Please answer the following questions about your main field of study:
                          a. What was the name of your field of study? ____________ (a string response)
                          b. Select a 3-digit code from page 7 that most closely describes the above? _ _ _ (a numeric or coded response)
                     A QuestionGroup can be considered distinct again from Questions with SubQuestions, as in the latter the type of
                     response is the same for all SubQuestions.
                  </xs:documentation>
               </xs:annotation>
               <xs:complexContent>
                  <xs:extension base="BaseQuestionType">
                     <xs:sequence>
                        <xs:element name="GroupedQuestions" minOccurs="1" maxOccurs="1">
                           <xs:complexType>
                              <xs:sequence maxOccurs="unbounded">
                                 <xs:element name="Question" type="QuestionType">
                                    <xs:unique name="QuestionGroupQuestionTextLanguageMustBeUnique">
                                       <xs:selector xpath="sqbl:TextComponent" />
                                       <xs:field xpath="@xml:lang" />
                                    </xs:unique>
                                 </xs:element>
                              </xs:sequence>
                              <xs:attribute name="randomised" type="xs:boolean" default="false" />
                           </xs:complexType>
                        </xs:element>
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
         </xs:element>
         <xs:element name="Statement">
            <xs:complexType>
               <xs:annotation>
                  <xs:documentation>A textual statement used in the Instrument and presented to a
                     respondent.</xs:documentation>
               </xs:annotation>
               <xs:complexContent>
                  <xs:extension base="BaseNamedType">
                     <xs:sequence>
                        <xs:element name="TextComponent" minOccurs="0" maxOccurs="unbounded">
                           <xs:annotation>
                              <xs:documentation> The Text component of a statement is all of the human readable parts
                                 that help describe a question.</xs:documentation>
                           </xs:annotation>
                           <xs:complexType>
                              <xs:all>
                                 <xs:element name="StatementText" maxOccurs="1" type="DynamicTextType">
                                    <xs:annotation>
                                       <xs:documentation>A string to be displayed in the instrument.</xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                              </xs:all>
                              <xs:attribute ref="xml:lang" />
                           </xs:complexType>
                        </xs:element>
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
            <xs:unique name="StatementTextLanguageMustBeUnique">
               <xs:selector xpath="sqbl:TextComponent" />
               <xs:field xpath="@xml:lang" />
            </xs:unique>
         </xs:element>

         <xs:element name="Question" type="QuestionType">
            <xs:unique name="QuestionTextLanguageMustBeUnique">
               <xs:selector xpath="sqbl:TextComponent" />
               <xs:field xpath="@xml:lang" />
            </xs:unique>
         </xs:element>
         <xs:element name="ModuleExitPoint">
            <xs:annotation>
               <xs:documentation> These operate like return statements in programming. If any of the conditionals are
                  true the respodent should leave this module. </xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:complexContent>
                  <xs:extension base="LogicNode">
                     <xs:sequence>
                        <xs:element name="Condition" minOccurs="1" maxOccurs="unbounded">
                           <xs:annotation>
                              <xs:documentation>The condition elements he order of Condition elements in a sequence
                                 guide is important and MUST NOT be changed without a survey editors understanding.
                                 Since it is the first condition that is true that is evaluated, changing the order of
                                 conditionals my change the order of a survey.</xs:documentation>
                           </xs:annotation>
                           <xs:complexType>
                              <xs:sequence>
                                 <xs:element name="ValueOf" minOccurs="1" maxOccurs="unbounded" type="ValueOfType">
                                    <xs:annotation>
                                       <xs:documentation>The order of the ValueOf elements does not matter, as they are
                                          all boolean 'and'ed together to for the final condition</xs:documentation>
                                    </xs:annotation>
                                 </xs:element>
                              </xs:sequence>
                           </xs:complexType>
                        </xs:element>
                     </xs:sequence>
                  </xs:extension>
               </xs:complexContent>
            </xs:complexType>
            <xs:unique name="ModuleExitPointTextLanguageMustBeUnique">
               <xs:selector xpath="sqbl:TextComponent" />
               <xs:field xpath="@xml:lang" />
            </xs:unique>
         </xs:element>

      </xs:choice>
   </xs:complexType>

   <xs:complexType name="DecisionTable">
      <xs:annotation>
         <xs:documentation><![CDATA[
            NB: CDATA sections are used below to preserve whitespace and paragraphs to make examples readable.
            
            A sequence guide is a specialised type of decision table used to describe the logical flow in a questionnaire.
            Each condition (or row) of the table is made up of a result and a series of conditional checks. These checks
            correspond to patial conditions that are used to test the value of specific questions used in this
            conditional table, and as such the number of checks in a condition must correspond exactly with the number
            of SourceQuestionReferences in the parent DecisionTableType object.
            
            When evaluating a sequence guide all conditions are considered to be false, and each
            condition is lazily evaluated from top to bottom, so that as oon as a condition is met the value of that
            condition is considered the value of the table itself. When evaluating a condition if every 'check'
            evaluates to true, the condition is considered to be true and the 'result' of that condition MUST to used as
            the evaluated value of the decision table. 
            
            When evaluating a
            check, a check is considered to be a partial boolean expression where the value of a question, where the
            position of the check corresponds to the position of the SourceQuestionReference in the parent object. When
            evaluating the check, the value of the question should be considered to take the left hand value of the
            expression. When a check is empty it MAY be skipped or evaluated to a boolean true - i.e. a condition with
            all empty checks will always be true. If no condition is evaluated as true, then the value of the
            'otherwise' object MUST be used as the evaluated value of the table. Where no condition is evaluated as true
            and no otherwise element exists, the table SHOULD be evaluated to be boolean false, however this may be
            dependant on implementations.
            
            It is considered best practise for Sequence Guide creator to included either
            exhaustive, mutually exlusive conditions, or to have an otherwise element to ensure a decision table has a
            definate evaluated value, as such UI designers SHOULD attempt to highlight when a decision table may be
            un-evaluated. In this context, the purpose of a sequence guide or decision table is to evaluate to a single
            value based on one or more questions. This value may then be used to control the flow in a wider context.
            Decision Tables are used to control sequence guides in conditionals and loops.
            
            For example, consider the following questions: 
                 Q1: Do you have a full-time job? Y/N
                 Q2: Do you have a part-time job? Y/N
            With the following decision table (best viewed in a mono-space font):
            
                              Result     |   Q1    |    Q2   |
                 Condition: "Employed"   |    ='Y' |         |
                 Condition: "Employed"   |         |    ='Y' |
                 Otherwise: "Unemployed" |
                 
            In the above case, we will evaluate three different instances, when a person (p1) says yes to both Q1 and
            Q2, when a person (p2) says no to Q1 and yes to Q2, and when a person (p3) says no both to Q1 and Q2.
            Evaluating p1 after they have answered both questions gives:
                             Result     |   Q1    |    Q2   |
                Condition: "Employed"   | 'Y'='Y' |         |    #True
                Condition: "Employed"   |         | 'Y'='Y' |    #True
                Otherwise: "Unemployed" |
                
            In this case, since the first condition was evaluated the earliest evaluated as true, the table is evaluated
            as ""Employed". The fact that the second condtion was also true has no bearing on the evaluation. Evaluating
            p2 after they have answered both questions gives:
                            Result     |   Q1    |    Q2   |
               Condition: "Employed"   | 'N'='Y' |         |    #False
               Condition: "Employed"   |         | 'Y'='Y' |    #True
               Otherwise: "Unemployed" |
               
            As the second condition is the earliest to be evaluated as true, again the table is evaluated to be
            "Employed" Evaluating p3 after they have answered both questions gives:
                              Result     |   Q1    |    Q2   |
                 Condition: "Employed"   | 'N'='Y' |         |    #False
                 Condition: "Employed"   |         | 'N'='Y' |    #False
                 Otherwise: "Unemployed" |
        
            As no condition has been evaluated to true, the result attached to the otherwise condition is used as the
            evaluated value of the table. Lastly, the IfCondition, might include a Code that specified that the
            IfCondition is true if the value of this DecisionTable is "Employed", causing the Employed branch to be
            evaluated to display a series of labour force questions to a user.
            ]]>
         </xs:documentation>
      </xs:annotation>
      <xs:sequence>
         <xs:element name="Condition" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation>
               <xs:documentation>The order of Condition elements in a sequence guide is important and MUST NOT be
                  changed without a survey editors understanding. Since it is the first condition that is true that is
                  evaluated, changing the order of conditionals my change the order of a survey.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:sequence>
                  <xs:element name="ValueOf" minOccurs="1" maxOccurs="unbounded" type="ValueOfType">
                     <xs:annotation>
                        <xs:documentation>The order of the ValueOf elements does not matter, as they are all boolean
                           'and'ed together to for the final condition</xs:documentation>
                     </xs:annotation>
                  </xs:element>
               </xs:sequence>
               <xs:attribute name="resultBranch" use="required" type="xs:IDREF">
                  <xs:annotation>
                     <xs:documentation> The ResultBranch is the name of the local path of population that is considered
                        to be 'active' if this condition is evaluated as 'True'. The name referenced here MUST be the
                        name of an immediate child object of the object that contains this DecisionTable. This should be
                        possible to enforce in schema, but a solution is still being sought. </xs:documentation>
                  </xs:annotation>
               </xs:attribute>

            </xs:complexType>
         </xs:element>
         <xs:element name="Otherwise" minOccurs="0" maxOccurs="1">
            <xs:annotation>
               <xs:documentation> The branch is the name of the local path of population that is considered to be
                  'active' if no other condition in the sequence guide is evaluated as 'True'. The name referenced here
                  MUST be the name of an immediate child object of the object that contains this DecisionTable. This
                  should be possible to enforce in schema, but a solution is still being sought. The specification of
                  one branch as the "default" within the "otherwise" reference, DOES NOT restrict it as being used in as
                  the result branch of a condition. </xs:documentation>
            </xs:annotation>
            <xs:complexType>
               <xs:attribute name="branch" use="required" type="xs:IDREF" />
            </xs:complexType>
         </xs:element>
      </xs:sequence>
   </xs:complexType>
   <xs:complexType name="ValueOfType">
      <xs:annotation>
         <xs:documentation><![CDATA[
            A value evaluates to 'true' if the result of the question given by the question attribute
            matches the value in this element evaluated using the listed expression. For example: 
            
              <ValueOf question="sex" is="equal_to">Male</Value>
              
            IMPORTANT NOTE: A ValueOf references a question, and are assumed to operate on questions with a single response.
            As such, questions with multiple responses that are included in decision tables may have undefined behaviour
            across form creation systems. This does not include CodeList with extra text fields, as these are managed in
            a different fashion to multiple responses, however the freeText response MUST not be made accessible for use in a
            decision table.  
            
             Would be true if when this was evaluated, a respondent had answered "Male" to the question with the name
            'sex'. It is RECOMMENED that when possible the ValueOf element has the @question attribute prior to the @is
            attiribute to make the XML as human readable as possible.Contrast the readability of
                  <ValueOf question="sex" is="equal_to">Male</Value>
                Which reads as:  "Value of question sex, is equal_to, Male" compared to:
                  <ValueOf  is="equal_to" question="sex">Male</Value>
                Which reads as: "Value of is equal_to, question sex, Male".
            ]]>
         </xs:documentation>
      </xs:annotation>
      <xs:simpleContent>
         <xs:extension base="xs:string">
            <xs:attribute name="question" use="required" type="xs:IDREF" />
            <xs:attribute name="is" use="required" type="Expressions" />
         </xs:extension>
      </xs:simpleContent>
   </xs:complexType>


   <xs:complexType name="Versionable">
      <xs:complexContent>
         <xs:extension base="BaseNamedType">
            <xs:sequence>
               <xs:element name="VersioningRationale" type="xs:string" minOccurs="0" maxOccurs="1">
                  <xs:annotation>
                     <xs:documentation>Textual description of the rationale/purpose for a version change. This should
                        describe why a change has been made to the object.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="version">
               <xs:simpleType>
                  <xs:restriction base="xs:nonNegativeInteger" />
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="BaseNamedType">
      <xs:annotation>
         <xs:documentation>The base type, this ensures that 'base objects' will have consistant content regardless of
            type.</xs:documentation>
      </xs:annotation>
      <xs:attribute name="name" use="required">
         <xs:annotation>
            <xs:documentation>The short name of the identified object (maximum 32 characters). This should attempt to be
               'human readable', and is required to be unique within the XML Document of a specific module. In practise
               this may be used in user-interfaces to quickly identify the object from a longer list of objects, such as
               a list of question modules or questions, so should be as descriptive as space allows. The maximum is set
               to enable compatibility with legacy software, as well as to provide a quickly readable option for
               interface designers. This name MAY be concatenated with the name of a parent module when this enhances
               understanding. When concatenated this should be done using dot notation, but MAY be changed accordingly.
               This field is based on the XML QName, and cannot have spaces, but inferface designers MAY choose to map
               underscores to spaces for readability when displaying. When converting from underscores to spaces, this
               SHOULD be made clear to users of any software that implements this format, and should be consistent
               within the environment. Given the systems and UI specific nature of this object for identification this
               is NOT multilingual and this WILL NOT change in future editions of the SQBL format. Multilingual
               descriptors for objects MUST be placed in the TextComponent of an object where it is available.
            </xs:documentation>
         </xs:annotation>
         <xs:simpleType>
            <xs:restriction base="xs:ID">
               <xs:maxLength value="32" />
            </xs:restriction>
         </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="presentationTypes" use="optional" type="xs:normalizedString">
         <xs:annotation>
            <xs:documentation>
               This is a space delimited list of strings indicating specialised types that this particular object takes on.
               These codes do not come from a controlled list, and this is unlikely to change in the future.
               
               An example of how these might be used is when directly copied into an XHTML represntation of a form derived
               from a SQBL document, where this list of presentationTypes becomes the class attribute for an XHTML element.
               
               These codes are for presentation ONLY, and developers MUST NOT uses presentationTypes for attempting to embed
               additional information within a SQBL document. For example the below is considered bad practise
                 e.g presentationTypes="myAppName:systemID:XXXXX"    --- DO NOT DO THIS!!!!
               Embeding such key:value pairs in the presentationTypes MUST NOT be done, and if detected by a a SQBL developer,
               said developer MUST hunt down the creator of the offending attribute and slap them with a fish!

               Said fish SHOULD come from a local, eco-friendly and renewable fishery.
            </xs:documentation>
         </xs:annotation>
      </xs:attribute>

   </xs:complexType>
   <xs:simpleType name="ReferenceType">
      <xs:annotation>
         <xs:documentation>Used for referencing an identified entity via by URI. It is expected that a system or use
            entering this URI has verified it validness and that it is the content at this URI is appropriately
            actionable by a system. </xs:documentation>
      </xs:annotation>
      <xs:restriction base="xs:anyURI" />
   </xs:simpleType>
   <xs:simpleType name="Expressions">
      <xs:restriction base="xs:string">
         <xs:enumeration value="equal_to" />
         <xs:enumeration value="not_equal_to" />
         <xs:enumeration value="less_than" />
         <xs:enumeration value="less_than_eq" />
         <xs:enumeration value="greater_than" />
         <xs:enumeration value="greater_than_eq" />
         <xs:enumeration value="inclusive_of">
            <xs:annotation>
               <xs:documentation>AKA. contains </xs:documentation>
            </xs:annotation>
         </xs:enumeration>
         <xs:enumeration value="match_for">
            <xs:annotation>
               <xs:documentation>AKA. regex </xs:documentation>
            </xs:annotation>
         </xs:enumeration>
      </xs:restriction>
   </xs:simpleType>

</xs:schema>
